import React from 'react';
import { COMPONENT_REGISTRY } from './ComponentRegistry';

/**
 * ThesysGenUI - Client-Side Rendering Engine for Generative UI
 * 
 * This engine takes a JSON specification (generated by AI) and constructs
 * a dynamic React component tree. It supports:
 * 1. Infinite nesting (Rows, Columns, Grids)
 * 2. Specialized Financial Components ("LEGO Blocks")
 * 3. Interactions (Drill-downs, Actions)
 */

// --- 1. Component Registry ---



/**
 * Recursive Renderer
 * Traverses the JSON tree and renders React components
 */
const renderTree = (node, key, handlers) => {
  if (!node) {
      return null;
  }
  
  // If node is just a string/number, render it
  if (typeof node === 'string' || typeof node === 'number') {
      // console.log('[ThesysGenUI] renderTree: Rendering primitive', node);
      return node;
  }

  // ROBUSTNESS FIX: Handle both "props" wrapper and flat properties
  // The AI sometimes forgets to wrap properties in a "props" object.
  // Thesys Native uses "component" instead of "type"
  const { type, component, children: directChildren, props: explicitProps, ...flatProps } = node;
  
  // Resolve type from either "type" or "component"
  let resolvedType = type || component;

  // HEURISTIC: If no type is found, try to infer from properties
  if (!resolvedType) {
    if (flatProps.text && flatProps.variant) resolvedType = 'Tag';
    else if (flatProps.textMarkdown) resolvedType = 'TextContent';
  }

  // console.log(`[ThesysGenUI] renderTree: Resolving component '${resolvedType}'`, { key, explicitProps, flatProps });

  // Resolve Children from either direct children OR props.children
  // Priority: Direct > Props.children
  let childrenToRender = directChildren;
  if (!childrenToRender && explicitProps && explicitProps.children) {
    childrenToRender = explicitProps.children;
  }
  
  // Clean props to avoid passing raw objects as children to React Components
  const { children: propsChildren, ...cleanExplicitProps } = explicitProps || {};

  // Merge explicit props (if any) with flat properties
  const mergedProps = {
    ...cleanExplicitProps,
    ...flatProps
  };

  // PRE-RENDER any prop that looks like a component object (has "component" or "type" key)
  // This fixes the "Objects are not valid as a React child" error for nested props like lhs, rhs, child
  const processedProps = {};
  for (const [propKey, propValue] of Object.entries(mergedProps)) {
    if (propValue && typeof propValue === 'object' && !Array.isArray(propValue)) {
      // Check if it looks like a component definition
      if (propValue.component || propValue.type) {
        processedProps[propKey] = renderTree(propValue, `${key}-prop-${propKey}`, handlers);
      } else {
        processedProps[propKey] = propValue;
      }
    } else {
      processedProps[propKey] = propValue;
    }
  }

  const Component = COMPONENT_REGISTRY[resolvedType] || COMPONENT_REGISTRY['container']; // Fallback
  
  if (!COMPONENT_REGISTRY[resolvedType]) {
    console.warn(`[ThesysGenUI] Unknown component type: '${resolvedType}'. Falling back to container.`);
  }

  // Prepare props with handlers
  const componentProps = {
    ...processedProps,
    onAction: handlers.onAction, // Pass global handlers down
    onDrillDown: handlers.onDrillDown,
    onSimulate: handlers.onSimulate
  };

  // If children exist, recursively render them
  const renderedChildren = Array.isArray(childrenToRender)
    ? childrenToRender.map((child, idx) => renderTree(child, `${key}-${idx}`, handlers))
    : childrenToRender
      ? renderTree(childrenToRender, `${key}-0`, handlers)
      : null;

  return (
    <Component key={key} {...componentProps}>
      {renderedChildren}
    </Component>
  );
};

/**
 * Main Entry Point
 * @param {string} componentType - The root alias (or 'layout' for full genUI)
 * @param {object} data - The props or the full layout JSON
 * @param {function} onAction - Handler for clicks/suggestions
 * @param {function} onDrillDown - Handler for chart clicks
 */
const ThesysGenUI = ({ componentType, data, onAction, onDrillDown }) => {
  // Interaction Handlers (passed down to all components)
  const handlers = {
    onAction,
    onDrillDown,
    onSimulate: (val) => onAction ? onAction(`Simulate: ${JSON.stringify(val)}`) : null
  };

  // MODE A: Full Generative Layout (New Engine)
  // Server sends: componentType="layout", data={ type: "row", children: [...] }
  if (componentType === 'layout' || componentType === 'genui' || componentType === 'thesys_genui') {
    // Unwrap data if it comes from the API wrapper
    const layoutData = data.generated_ui || data;
    
    return (
      <div className="w-full my-4 animate-fade-in">
        {renderTree(layoutData, 'root', handlers)}
      </div>
    );
  }

  // MODE B: Single Component (Backward Compatibility / Fallback)
  // Server sends: componentType="bar_chart", data={...props}
  // We wrap it in a mock layout node to reuse the renderer
  const rootNode = {
    type: componentType,
    props: data.generated_ui || data
  };

  return (
    <div className="w-full my-2 animate-slide-up">
      {renderTree(rootNode, 'single-root', handlers)}
    </div>
  );
};

export default ThesysGenUI;
